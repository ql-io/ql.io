/*
 * Copyright 2011 eBay Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Tokenize strings for '{' and '}'
{
    function typeOf(value) {
        var s = typeof value;
        if(s === 'object') {
            if(value) {
                if(typeof value.length === 'number' &&
                    !(value.propertyIsEnumerable('length')) &&
                    typeof value.splice === 'function') {
                    s = 'array';
                }
            }
            else {
                s = 'null';
            }
        }
        return s;
    }
    function append(arr) {
        var str = '';
        for(var i = 0; i < arr.length; i++) {
            if(typeOf(arr[i]) == 'array') {
                str += append(arr[i]);
            }
            else if (typeof arr[i] === 'object') {
                str += JSON.stringify(arr[i].object);
            }
            else {
                str += arr[i];
            }
        }
        return str;
    }
}
start = template

template  = c:( expression / literal )* {
    var o = [];
    o.push(c[0]);
    var current = 0;
    for(var i = 1; i < c.length; i++) {
        if(typeof c[i] === 'string' && typeof o[current] === 'string') {
            o[current] = o[current] + c[i];
        }
        else {
            o.push(c[i]);
            current++;
        }
    }
    var tokenCount = 0;
    for(i = 0; i < c.length; i++) {
      if(c[i].variable) tokenCount++;
    }
    return {
        format: function(bag, keep) {
            var str = '', i, j, ref, current;
            for(i = 0; i < o.length; i++) {
                if(typeof o[i] === 'string') {
                    str = str + o[i];
                }
                else {
                    current = o[i].variable;
                    ref = bag;
                    for(j = 0; j < current.length; j++) {
                        ref = ref[current[j]];
                        if(ref === undefined) {
                            break;
                        }
                    }
                    if(ref) {
                        str = str + ref;
                    }
                    else if(keep) {
                        str = str + '{' + o[i].variable + '}'
                    }
                }
            }
            var ss = parse(str);
            if(ss.tokenCount > 0) {
                str = ss.format(bag, keep);
                ss = parse(str);
            }
            return str;
        },
        stream: o,
        tokenCount: tokenCount
    }
}

literal = ([^"'<>\'`'] / ' ')

expression =  "{" v:variable "}" {
    return {
        variable: v
    }
}

operator = '^'

identifier = obj:(word ('.' word)*) {
    return append(obj);
}

word = chars:([a-zA-Z$][a-zA-Z_0-9]*)  {
    var ret = chars[0];
    for(i = 1; i < chars.length; i++) {
        ret = ret + chars[i].join('');
    }
    return ret;
}

variable = l:identifier* {
    var r = '';
    for(i = 0; i < l.length; i++) { r += l[i]; }
    return r.split('.');
}
